<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script type="module">

        
        const smoothstep = (t) => t * t * (3 - 2 * t);
        const dot_product = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1];
        const dist = (p1, p2) => [p2[0] - p1[0], p2[1] - p1[1]];
        
        const interp_point = (corners, p, dots, smooth) => {
            let tx, ty;
            if (smooth) {
                tx = smoothstep(p[0] - corners[0][0]);
                ty = smoothstep(p[1] - corners[0][1]);
            } else {
                tx = p[0] - corners[0][0];
                ty = p[1] - corners[0][1];
            }
            const ix0 = dots[0] * (1 - tx) + dots[1] * tx;
            const ix1 = dots[2] * (1 - tx) + dots[3] * tx;
            return ix0 * (1 - ty) + ix1 * ty;
        };

        function sha256(ascii) {
    function rightRotate(value, amount) {
        return (value >>> amount) | (value << (32 - amount));
    }

    const mathPow = Math.pow;
    const maxWord = mathPow(2, 32);
    let result = '';

    const words = [];
    const asciiBitLength = ascii.length * 8;

    const hash = [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ];

    const k = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];

    ascii += '\x80'; // Append '1' bit and seven '0' bits
    while ((ascii.length % 64) - 56) ascii += '\x00';

    for (let i = 0; i < ascii.length; i++) {
        const j = ascii.charCodeAt(i);
        if (j >> 8) return; // ASCII only
        words[i >> 2] |= j << ((3 - (i % 4)) * 8);
    }

    words[words.length] = (asciiBitLength / maxWord) | 0;
    words[words.length] = asciiBitLength;

                for (let j = 0; j < words.length; ) {
                    const w = words.slice(j, j += 16);
                    const oldHash = hash.slice();
                    for (let i = 0; i < 64; i++) {
                        const w15 = w[i - 15], w2 = w[i - 2];
                        const a = hash[0], b = hash[1], c = hash[2], d = hash[3];
                        const e = hash[4], f = hash[5], g = hash[6], h = hash[7];

                        const s0 = rightRotate(w15 || 0, 7) ^ rightRotate(w15 || 0, 18) ^ ((w15 || 0) >>> 3);
                        const s1 = rightRotate(w2 || 0, 17) ^ rightRotate(w2 || 0, 19) ^ ((w2 || 0) >>> 10);

                        w[i] = (i < 16 ? w[i] : (w[i - 16] + s0 + w[i - 7] + s1) | 0);

                        const ch = (e & f) ^ (~e & g);
                        const maj = (a & b) ^ (a & c) ^ (b & c);
                        const temp1 = (h + ((e >>> 6) ^ (e >>> 11) ^ (e >>> 25)) + ch + k[i] + w[i]) | 0;
                        const temp2 = (((a >>> 2) ^ (a >>> 13) ^ (a >>> 22)) + maj) | 0;

                        hash[7] = hash[6];
                        hash[6] = hash[5];
                        hash[5] = hash[4];
                        hash[4] = (d + temp1) | 0;
                        hash[3] = hash[2];
                        hash[2] = hash[1];
                        hash[1] = hash[0];
                        hash[0] = (temp1 + temp2) | 0;
                    }

                    for (let i = 0; i < 8; i++) {
                        hash[i] = (hash[i] + oldHash[i]) | 0;
                    }
                }

                for (let i = 0; i < hash.length; i++) {
                    result += ('00000000' + (hash[i] >>> 0).toString(16)).slice(-8);
                }

                return result;
            }


        
        const generateUnitVector = (x, y, seed, angleOffset) => {
            // Use SHA256 for high-quality hashing
            const input = `${x},${y},${seed}`;
            const hash = sha256(input).toString();
            // Take first 8 hex characters and convert to number between 0 and 1
            const hashNum = parseInt(hash.substring(0, 8), 16) / 0xFFFFFFFF;
            const angle = hashNum * 2 * Math.PI + angleOffset;
            return [Math.cos(angle), Math.sin(angle)];
        };
        
        function generateNoiseGrid(seed, inc_amount, gridWidth, gridHeight, subDiv, smooth) {
            const currentAngle = inc_amount;
            const vertsX = gridWidth;
            const vertsY = gridHeight;
            
            // Generate gradient vectors at each grid vertex
            const edges = [];
            for (let x = 0; x < vertsX; x++) {
                const row = [];
                for (let y = 0; y < vertsY; y++) {
                    row.push({
                        coords: [x, y],
                        unitVector: generateUnitVector(x, y, seed, currentAngle),
                    });
                }
                edges.push(row);
            }
            
            // Generate noise values by sampling within each grid cell
            const noiseGrid = [];
            
            for (let y = 0; y < vertsY - 1; y++) {
                for (let x = 0; x < vertsX - 1; x++) {
                    // Get the four corners of this grid cell
                    const corners = [
                        edges[x][y],
                        edges[x + 1][y],
                        edges[x][y + 1],
                        edges[x + 1][y + 1],
                    ];
                    
                    // Sample subDiv points within this cell
                    for (let j = 0; j < subDiv; j++) {
                        const gridY = y * subDiv + j;
                        if (!noiseGrid[gridY]) noiseGrid[gridY] = [];
                        
                        for (let i = 0; i < subDiv; i++) {
                            const gridX = x * subDiv + i;
                            
                            // Calculate the actual point position (0 to 1 within the cell)
                            const localX = (i + 0.5) / subDiv;
                            const localY = (j + 0.5) / subDiv;
                            
                            const point = [
                                corners[0].coords[0] + localX,
                                corners[0].coords[1] + localY,
                            ];
                            
                            // Calculate dot products with gradients at each corner
                            const dots = corners.map((corner) =>
                                dot_product(dist(corner.coords, point), corner.unitVector)
                            );
                            
                            // Interpolate to get final noise value
                            const val = interp_point(
                                corners.map((c) => c.coords),
                                point,
                                dots,
                                smooth
                            );
                            
                            noiseGrid[gridY][gridX] = val;
                        }
                    }
                }
            }
            return noiseGrid;
        }
        

function getHeatmapColor(value) {
    const t = (value + 1) / 2;

    let r = 0, g = 0, b = 0;

    if (t <= 0.2) {         // dark blue to blue
        r = 0;
        g = 0;
        b = 128 + Math.round(t / 0.2 * 127); // 128 to 255
    } else if (t <= 0.4) {  // blue to cyan
        r = 0;
        g = Math.round((t - 0.2) / 0.2 * 255); // 0 to 255
        b = 255;
    } else if (t <= 0.6) {  // cyan to green
        r = 0;
        g = 255;
        b = 255 - Math.round((t - 0.4) / 0.2 * 255); // 255 to 0
    } else if (t <= 0.8) {  // green to yellow
        r = Math.round((t - 0.6) / 0.2 * 255); // 0 to 255
        g = 255;
        b = 0;
    } else {                // yellow to red
        r = 255;
        g = 255 - Math.round((t - 0.8) / 0.2 * 255); // 255 to 0
        b = 0;
    }
    return [r, g, b];
}   
        
        // Generate the grid
        const seed = 42;
        let inc_amount = 0.1;
        const gridWidth = 10;
        const gridHeight = 10;
        const subDiv = 18;
        const smooth = true;
        
function drawFrame() {

    const noiseGrid = generateNoiseGrid(seed, inc_amount, gridWidth, gridHeight, subDiv, smooth);

    const width = noiseGrid[0].length;
    const height = noiseGrid.length;

    canvas.width = width;
    canvas.height = height;

    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const value = noiseGrid[y][x];
            const [r, g, b] = getHeatmapColor(value);
            const idx = (y * width + x) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);

    inc_amount += 0.03;

    requestAnimationFrame(drawFrame);
}

drawFrame()

    </script>
</body>
</html>